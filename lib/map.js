// Generated by CoffeeScript 1.7.1

/*
    D3 County Map Template
    Ben Southgate
    9/29/14
 */

(function() {
  var Map, mapError;

  mapError = function(text) {
    throw "Urban Map Error : " + text;
  };

  Map = (function() {
    function Map(options) {
      var o, opt, required, self, us, _i, _len, _ref;
      self = this;
      if (options == null) {
        options = {};
      }
      required = ['csv', 'colors', 'countyID', 'displayVariable', 'renderTo'];
      for (_i = 0, _len = required.length; _i < _len; _i++) {
        opt = required[_i];
        if ((o = options[opt])) {
          self[opt] = o;
        } else {
          mapError("\"" + opt + "\" not provided to Map.");
        }
      }
      this.tooltip = (_ref = options.tooltip) != null ? _ref : {
        formatter: (function() {}),
        opacity: 0
      };
      if ((us = Urban.cache[options.geoJson])) {
        self.countyJson = us;
        self.loadCSV(self.csv, function() {
          self.render();
          return self.update(self.displayVariable);
        });
      } else {
        d3.json(options.geoJson, function(e, us) {
          Urban.cache[options.geoJson] = us;
          self.countyJson = us;
          console.log(us);
          return self.loadCSV(self.csv, function() {
            self.render();
            return self.update(self.displayVariable);
          });
        });
      }
    }

    Map.prototype.loadCSV = function(filename, callback) {
      var cache, cid, self;
      self = this;
      cid = self.countyID;
      cache = Urban.cache;
      if (cache[filename]) {
        self.data = cache[filename];
        callback();
      } else {
        d3.csv(filename, function(e, data) {
          var d, row, _i, _len;
          self.data = d = {};
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            row = data[_i];
            if (!(cid in row)) {
              mapError("" + cid + " not in csv!");
            }
            d[row[cid]] = row;
          }
          return callback();
        });
      }
      return self;
    };

    Map.prototype.render = function() {
      var df, formatter, height, opacity, path, projection, renderToElement, self, stateTopoData, svg, tooltipDiv, topodata, width;
      self = this;
      width = this.width = 1011;
      height = this.hieght = 588;
      projection = d3.geo.albersUsa().scale(width).translate([width / 2, height / 2]);
      path = d3.geo.path().projection(projection);
      renderToElement = d3.select(this.renderTo);
      svg = renderToElement.html('').append('svg').attr({
        "class": "urban-map",
        preserveAspectRatio: "xMinYMin slice",
        viewBox: "0 0 " + width + " " + height
      }).append('g');
      this.legend = svg.append('g').attr({
        "class": 'urban-map-legend'
      });
      topodata = topojson.feature(this.countyJson, this.countyJson.objects.counties).features;
      stateTopoData = topojson.mesh(this.countyJson, this.countyJson.objects.states, function(a, b) {
        return a !== b;
      });
      d3.select('div.urban-map-tooltip').remove();
      tooltipDiv = d3.select('body').append('div').attr('class', 'urban-map-tooltip').style({
        display: "block",
        position: "absolute",
        opacity: 0
      });
      d3.select('body').on('mousemove', function() {
        var tt_bbox, x, y, _ref;
        _ref = [d3.event.pageX, d3.event.pageY], x = _ref[0], y = _ref[1];
        tooltipDiv = d3.select('div.urban-map-tooltip');
        tt_bbox = tooltipDiv.node().getBoundingClientRect();
        return tooltipDiv.style({
          top: "" + (y - tt_bbox.height - 10) + "px",
          left: "" + (x - tt_bbox.width / 2) + "px"
        });
      });
      df = self.data;
      formatter = self.tooltip.formatter;
      opacity = self.tooltip.opacity;
      this.counties = svg.append('g').selectAll('path').data(topodata).enter().append('path').attr({
        "class": 'urban-map-counties',
        id: function(d) {
          return d.id;
        },
        d: path
      }).on('mouseover', function() {
        var county_data, _ref;
        tooltipDiv = d3.select('div.urban-map-tooltip');
        county_data = this.id in df ? df[this.id] : {};
        county_data._county_name = (_ref = Urban.countyNames) != null ? _ref[this.id] : void 0;
        return tooltipDiv.html(formatter.call(county_data)).transition().duration(100).style({
          opacity: opacity
        });
      }).on('mouseout', function() {
        tooltipDiv = d3.select('div.urban-map-tooltip');
        return tooltipDiv.transition().duration(100).style({
          opacity: 0
        });
      });
      svg.append("path").datum(stateTopoData).attr({
        "class": "urban-map-states",
        d: path
      }).style({
        fill: 'none'
      });
      return self;
    };

    Map.prototype.update = function(var_obj) {
      var b, binWidth, bins, c, center, color, colors, enable, fill, fmt, missingColor, name, self, time, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      self = this;
      bins = this.bins = (_ref = (_ref1 = var_obj.breaks) != null ? _ref1 : this.bins) != null ? _ref : mapError("No bins provided!");
      name = (_ref2 = var_obj.name) != null ? _ref2 : mapError("No variable name provided!");
      missingColor = this.missingColor = var_obj.missingColor || "#aaa";
      colors = this.colors = (_ref3 = var_obj.colors) != null ? _ref3 : this.colors;
      fmt = this.fmt = (_ref4 = (_ref5 = (_ref6 = var_obj.legend) != null ? _ref6.formatter : void 0) != null ? _ref5 : this.fmt) != null ? _ref4 : function() {
        return this.value;
      };
      binWidth = this.binWidth = (_ref7 = (_ref8 = (_ref9 = var_obj.legend) != null ? _ref9.binWidth : void 0) != null ? _ref8 : this.binWidth) != null ? _ref7 : 40;
      enable = this.enable = (_ref10 = (_ref11 = (_ref12 = var_obj.legend) != null ? _ref12.enabled : void 0) != null ? _ref11 : this.enabled) != null ? _ref10 : true;
      b = bins.length;
      c = colors.length;
      if (b > c) {
        throw "" + (b - c) + " more bins than colors!";
      }
      if (b < c) {
        throw "" + (c - b) + " more colors than bins!";
      }
      color = d3.scale.threshold().domain(bins).range(colors);
      this.legend.empty();
      if (enable) {
        center = (this.width - (binWidth * bins.length)) / 2;
        this.legend.selectAll('rect').data(bins).enter().append('rect').attr({
          width: binWidth,
          height: binWidth * 0.5,
          x: function(d, i) {
            return center + i * binWidth;
          },
          y: 50
        }).style({
          fill: function(d) {
            return color(d * (d === 0 ? -0.01 : d > 0 ? 0.99 : 1.01));
          }
        });
        this.legend.selectAll('text').data(bins.slice(0, -1)).enter().append('text').text(function(d) {
          return fmt.call({
            value: d
          });
        }).attr({
          y: 40,
          x: function(d, i) {
            return center + (i + 1) * binWidth - binWidth / 3;
          }
        });
      }
      fill = function(p) {
        var v, _ref13, _ref14;
        v = (_ref13 = self.data) != null ? (_ref14 = _ref13[p.id]) != null ? _ref14[name] : void 0 : void 0;
        if (v) {
          return color(v);
        } else {
          return missingColor;
        }
      };
      if ((time = var_obj.transition)) {
        this.counties.transition().duration(Math.abs(time)).attr('fill', fill);
      } else {
        this.counties.attr('fill', fill);
      }
      return self;
    };

    return Map;

  })();

  (function() {
    var Urban;
    Urban = Urban || {};
    if (Urban.cache == null) {
      Urban.cache = {};
    }
    Urban.Map = Map;
    return window.Urban = Urban;
  })();

}).call(this);
